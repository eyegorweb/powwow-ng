"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

type AccessPoint {
  id: ID!
  commercialStatus: String
}

type BankAccount {
  name: String
  number: String
  establishmentCode: String
}

type Country implements Node {
  id: ID!
  code: String
}

input CountryFilterInput {
  code: StringFilterInput
}

type CountryResponse {
  total: Int!
  countries: [Country]
}

input CountrySorting {
  id: SortDirection
  code: SortDirection
}

type CustomerAccount implements Node {
  id: ID!
  code: String
  name: String
  siret: String
  marketLine: String
  siren: String
  party: Party
  bankAccount: BankAccount
}

input CustomerAccountFilterInput {
  code: StringFilterInput
  name: StringFilterInput
  siret: StringFilterInput
  marketLine: StringFilterInput
  siren: StringFilterInput
  partyId: IdFilterInput
}

type CustomerAccountResponse {
  total: Int!
  items: [CustomerAccount]
}

input CustomerAccountSorting {
  id: SortDirection
  name: SortDirection
}

"""Define here custom scalars"""
scalar Date

input DateFilterInput {
  eq: Date
  ne: Date
  gt: Date
  lt: Date
  goe: Date
  loe: Date
  between: DatesRange
}

input DatesRange {
  startDate: Date
  endDate: Date
}

input IdFilterInput {
  eq: ID
  ne: ID
  in: [ID!]
}

"""Long type"""
scalar Long

type MarketingOffer implements Node {
  id: ID!
  description: String
}

type Mutation {
  updateSIMCard(input: SIMCardInstanceInput!): SIMCardInstance!
}

type Name {
  title: Title
  firstName: String
  lastName: String
}

interface Node {
  id: ID!
}

input OfferFilterInput {
  description: StringFilterInput
  partyId: IdFilterInput
}

type OfferResponse {
  total: Int!
  items: [MarketingOffer]
}

input OfferSorting {
  id: SortDirection
  name: SortDirection
}

type Order implements Node {
  id: ID!
  creationDate: Date!
  orderDate: Date!
  party: Party
  deliveryNum: Int
  preActivationAsked: Boolean
  activationAsked: Boolean
  status: OrderStatusEnum
  orderItems: [OrderItem]
  customerAccount: CustomerAccount
}

type OrderedProduct {
  description: String
  code: String
  buyingPriceInEuroCentHT: Int
  recurringPriceInEuroCentHT: Int
  buyingPriceInEuroCentTTC: Int
  recurringPriceInEuroCentTTC: Int
  groupCode: String
  groupName: String
}

input OrderFilterInput {
  partyName: StringFilterInput
  orderDate: DateFilterInput
}

type OrderItem {
  quantity: Int
  orderedProduct: OrderedProduct
}

input OrderSorting {
  id: SortDirection
  creationDate: SortDirection
  orderDate: SortDirection
  partyName: SortDirection
  deliveryNum: SortDirection
  preActivationAsked: SortDirection
  activationAsked: SortDirection
  status: SortDirection
}

type OrdersResponse {
  total: Int!
  orders: [Order]
}

enum OrderStatusEnum {
  NOT_VALIDATED
  VALIDATED
  TO_BE_CONFIRMED
  TO_BE_CONFIRMED_BY_BO
  CONFIRMATION_IN_PROGRESS
  CONFIRMED
  FAILED
  TERMINATED
  CANCELED
}

input Pagination {
  limit: Int
  page: Int
}

type Party implements Node {
  id: ID!
  name: String!
  code: String!
  siren: String
  naf: String
}

input PartyFilterInput {
  name: StringFilterInput
  id: IdFilterInput
}

input PartySorting {
  id: SortDirection
  name: SortDirection
}

type PartysResponse {
  total: Int!
  items: [Party!]
}

type Query {
  countries(filter: CountryFilterInput, pagination: Pagination, sorting: CountrySorting): CountryResponse
  customerAccounts(filter: CustomerAccountFilterInput, pagination: Pagination, sorting: CustomerAccountSorting): CustomerAccountResponse
  offers(filter: OfferFilterInput, pagination: Pagination, sorting: OfferSorting): OfferResponse
  orders(filter: OrderFilterInput, pagination: Pagination, sorting: OrderSorting): OrdersResponse
  orderStatus: [OrderStatusEnum]
  party(id: Int!): Party
  partys(filter: PartyFilterInput, pagination: Pagination, sorting: PartySorting): PartysResponse
  findAllSimcards(page: Int, limit: Int): [SIMCardInstance]!
  findSimcardById(id: Int!): SIMCardInstance
  countSimcards: Long!
  getCurrentUser: User!
}

type SIMCardInstance {
  id: ID!
  iccid: String!
  type: String
  accessPoint: AccessPoint
}

input SIMCardInstanceInput {
  id: ID!
  iccid: String!
}

enum SortDirection {
  ASC
  DESC
}

input StringFilterInput {
  eq: String
  ne: String
  in: [String!]
  startsWith: String
  endsWith: String
  contains: String
}

enum Title {
  MR
  MISS
  MRS
}

type User {
  name: Name
  email: String
  isUserParty: Boolean
  partyName: String
  isBackOffice: Boolean
}
